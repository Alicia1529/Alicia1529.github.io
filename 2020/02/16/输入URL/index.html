<!DOCTYPE html>
<html lang="en,zh-CN,default">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>在浏览器中输入URL按下回车后发生了什么 | Aliciaaa</title>



    <link rel="icon" href="/favicon_a.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Alicia&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/resume">Resume</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Alicia&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/resume">Resume</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>

<!-- <script zIndex="-2" src="js/canvas-nest.js"></script> -->
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">在浏览器中输入URL按下回车后发生了什么</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Alicia Luo</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">February 16, 2020&nbsp;&nbsp;18:19:48</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Web/">Web</a>
                            
                            
                        </span>
                    
                    <span class="post-view">         
                        <span id="busuanzi_container_page_pv">
                            Views: <a id="busuanzi_value_page_pv"></a>
                        </span> 
                    </span>

                </div>
            
        </header>

        <div class="post-content">
            <p>从输入 URL 到页面加载完成的过程中都发生了什么事情？</p>
<p><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">SOURCE1</a></p>
<h2 id="第一个问题：从输入-URL-到浏览器接收的过程中发生了什么事情？"><a href="#第一个问题：从输入-URL-到浏览器接收的过程中发生了什么事情？" class="headerlink" title="第一个问题：从输入 URL 到浏览器接收的过程中发生了什么事情？"></a>第一个问题：从输入 URL 到浏览器接收的过程中发生了什么事情？</h2><h3 id="从触屏到-CPU"><a href="#从触屏到-CPU" class="headerlink" title="从触屏到 CPU"></a>从触屏到 CPU</h3><p>首先是「输入 URL」，大部分人的第一反应会是键盘，不过为了与时俱进，这里将介绍触摸屏设备的交互。</p>
<p>触摸屏一种传感器，目前大多是基于电容(Capacitive)来实现的，以前都是直接覆盖在显示屏上的，不过最近出现了 3 种嵌入到显示屏中的技术，第一种是 iPhone 5 的 In-cell，它能减小了 0.5 毫米的厚度，第二种是三星使用的 On-cell 技术，第三种是国内厂商喜欢用的 OGS 全贴合技术，具体细节可以阅读这篇文章。</p>
<p>当手指在这个传感器上触摸时，有些电子会传递到手上，从而导致该区域的电压变化，触摸屏控制器芯片根据这个变化就能计算出所触摸的位置，然后通过总线接口将信号传到 CPU 的引脚上。</p>
<h3 id="CPU-内部的处理"><a href="#CPU-内部的处理" class="headerlink" title="CPU 内部的处理"></a>CPU 内部的处理</h3><p>在时钟的控制下，这些电流会经过 MOSFET 晶体管，晶体管中包含 N 型半导体和 P 型半导体，通过电压就能控制线路开闭，然后这些 MOSFET 构成了 CMOS，接着再由 CMOS 实现「与」「或」「非」等逻辑电路门，最后由逻辑电路门上就能实现加法、位移等计算，整体如下图所示（来自《计算机体系结构》）：</p>
<h3 id="从操作系统-GUI-到浏览器"><a href="#从操作系统-GUI-到浏览器" class="headerlink" title="从操作系统 GUI 到浏览器"></a>从操作系统 GUI 到浏览器</h3><p>前面提到 Linux 内核已经完成了对硬件的抽象，其它程序只需要通过监听 /dev/input/event0 文件的变化就能知道用户进行了哪些触摸操作，不过如果每个程序都这么做实在太麻烦了，所以在图像操作系统中都会包含 GUI 框架来方便应用程序开发，比如 Linux 下著名的 X。</p>
<p>但 Android 并没有使用 X，而是自己实现了一套 GUI 框架，其中有个 EventHub 的服务会通过 epoll 方式监听 /dev/input/ 目录下的文件，然后将这些信息传递到 Android 的窗口管理服务(WindowManagerService)中，它会根据位置信息来查找相应的 app，然后调用其中的监听函数（如 onTouch 等）。</p>
<p>就这样，我们解答了第一个问题，不过由于时间有限，这里省略了很多细节，想进一步学习的读者推荐阅读以下书籍。</p>
<h2 id="第二个问题：浏览器如何向网卡发送数据？"><a href="#第二个问题：浏览器如何向网卡发送数据？" class="headerlink" title="第二个问题：浏览器如何向网卡发送数据？"></a>第二个问题：浏览器如何向网卡发送数据？</h2><h3 id="从浏览器到浏览器内核"><a href="#从浏览器到浏览器内核" class="headerlink" title="从浏览器到浏览器内核"></a>从浏览器到浏览器内核</h3><p>前面提到操作系统 GUI 将输入事件传递到了浏览器中，在这过程中，浏览器可能会做一些预处理，比如 Chrome 会根据历史统计来预估所输入字符对应的网站，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 」，因此就会在输入回车前就马上开始建立 TCP 链接甚至渲染了，这里面还有很多其它策略，感兴趣的读者推荐阅读 High Performance Networking in Chrome。</p>
<p>接着是输入 URL 后的「回车」，这时浏览器会对 URL 进行检查，首先判断协议，如果是 http 就按照 Web 来处理，另外还会对这个 URL 进行安全检查，然后直接调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。</p>
<p>在浏览器内核中会先查看缓存，然后设置 UA 等 HTTP 信息，接着调用不同平台下网络请求的方法。</p>
<p>需要注意浏览器和浏览器内核是不同的概念，浏览器指的是 Chrome、Firefox，而浏览器内核则是 Blink、Gecko，浏览器内核只负责渲染，GUI 及网络连接等跨平台工作则是浏览器实现的HTTP 请求的发送</p>
<p>因为网络的底层实现是和内核相关的，所以这一部分需要针对不同平台进行处理，从应用层角度看主要做两件事情：通过 DNS 查询 IP、通过 Socket 发送数据，接下来就分别介绍这两方面的内容。</p>
<h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><p>应用程序可以直接调用 Libc 提供的 getaddrinfo() 方法来实现 DNS 查询。</p>
<p>DNS 查询其实是基于 UDP 来实现的，这里我们通过一个具体例子来了解它的查找过程，以下是使用 dig +trace fex.baidu.com 命令得到的结果（省略了一些）：</p>
<pre><code>; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace fex.baidu.com
;; global options: +cmd
.           11157   IN  NS  g.root-servers.net.
.           11157   IN  NS  i.root-servers.net.
.           11157   IN  NS  j.root-servers.net.
.           11157   IN  NS  a.root-servers.net.
.           11157   IN  NS  l.root-servers.net.
;; Received 228 bytes from 8.8.8.8#53(8.8.8.8) in 220 ms

com.            172800  IN  NS  a.gtld-servers.net.
com.            172800  IN  NS  c.gtld-servers.net.
com.            172800  IN  NS  m.gtld-servers.net.
com.            172800  IN  NS  h.gtld-servers.net.
com.            172800  IN  NS  e.gtld-servers.net.
;; Received 503 bytes from 192.36.148.17#53(192.36.148.17) in 185 ms

baidu.com.      172800  IN  NS  dns.baidu.com.
baidu.com.      172800  IN  NS  ns2.baidu.com.
baidu.com.      172800  IN  NS  ns3.baidu.com.
baidu.com.      172800  IN  NS  ns4.baidu.com.
baidu.com.      172800  IN  NS  ns7.baidu.com.
;; Received 201 bytes from 192.48.79.30#53(192.48.79.30) in 1237 ms

fex.baidu.com.      7200    IN  CNAME   fexteam.duapp.com.
fexteam.duapp.com.  300 IN  CNAME   duapp.n.shifen.com.
n.shifen.com.       86400   IN  NS  ns1.n.shifen.com.
n.shifen.com.       86400   IN  NS  ns4.n.shifen.com.
n.shifen.com.       86400   IN  NS  ns2.n.shifen.com.
n.shifen.com.       86400   IN  NS  ns5.n.shifen.com.
n.shifen.com.       86400   IN  NS  ns3.n.shifen.com.
;; Received 258 bytes from 61.135.165.235#53(61.135.165.235) in 2 ms</code></pre><p>可以看到这是一个逐步缩小范围的查找过程，首先由本机所设置的 DNS 服务器(8.8.8.8)向 DNS 根节点查询负责 .com 区域的域务器，然后通过其中一个负责 .com 的服务器查询负责 baidu.com 的服务器，最后由其中一个 baidu.com 的域名服务器查询 fex.baidu.com 域名的地址。</p>
<p>可能你在查询某些域名的时会发现和上面不一样，最底将看到有个奇怪的服务器抢先返回结果。。。</p>
<blockquote>
<p>这里为了方便描述，忽略了很多不同的情况，比如 127.0.0.1 其实走的是 loopback，和网卡设备没关系；比如 Chrome 会在浏览器启动的时预先查询 10 个你有可能访问的域名；还有 Hosts 文件、缓存时间 TTL(Time to live)的影响等。</p>
</blockquote>
<h3 id="通过-Socket-发送数据"><a href="#通过-Socket-发送数据" class="headerlink" title="通过 Socket 发送数据"></a>通过 Socket 发送数据</h3><p>有了 IP 地址，就可以通过 Socket API 来发送数据了，这时可以选择 TCP 或 UDP 协议，具体使用方法这里就不介绍了，推荐阅读 Beej’s Guide to Network Programming。</p>
<p>HTTP 常用的是 TCP 协议，由于 TCP 协议的具体细节到处都能看到，所以本文就不介绍了，这里谈一下 TCP 的 Head-of-line blocking 问题：假设客户端的发送了 3 个 TCP 片段(segments)，编号分别是 1、2、3，如果编号为 1 的包传输时丢了，即便编号 2 和 3 已经到达也只能等待，因为 TCP 协议需要保证顺序，这个问题在 HTTP pipelining 下更严重，因为 HTTP pipelining 可以让多个 HTTP 请求通过一个 TCP 发送，比如发送两张图片，可能第二张图片的数据已经全收到了，但还得等第一张图片的数据传到。</p>
<p>为了解决 TCP 协议的性能问题，Chrome 团队去年提出了 QUIC 协议，它是基于 UDP 实现的可靠传输，比起 TCP，它能减少很多来回(round trip)时间，还有前向纠错码(Forward Error Correction)等功能。目前 Google Plus、 Gmail、Google Search、blogspot、Youtube 等几乎大部分 Google 产品都在使用 QUIC，可以通过 chrome://net-internals/#spdy 页面来发现。</p>
<p>虽然目前除了 Google 还没人用 QUIC，但我觉得挺有前景的，因为优化 TCP 需要升级系统内核（比如 Fast Open）。</p>
<p>浏览器对同一个域名有连接数限制，大部分是 6，我以前认为将这个连接数改大后会提升性能，但实际上并不是这样的，Chrome 团队有做过实验，发现从 6 改成 10 后性能反而下降了，造成这个现象的因素有很多，如建立连接的开销、拥塞控制等问题，而像 SPDY、HTTP 2.0 协议尽管只使用一个 TCP 连接来传输数据，但性能反而更好，而且还能实现请求优先级。<br>另外，因为 HTTP 请求是纯文本格式的，所以在 TCP 的数据段中可以直接分析 HTTP 的文本，如果发现。。。</p>
<h3 id="Socket-在内核中的实现"><a href="#Socket-在内核中的实现" class="headerlink" title="Socket 在内核中的实现"></a>Socket 在内核中的实现</h3><p>前面说到浏览器的跨平台库通过调用 Socket API 来发送数据，那么 Socket API 是如何实现的呢？</p>
<p>以 Linux 为例，它的实现在这里 socket.c，目前我还不太了解，推荐读者看看 Linux kernel map，它标注出了关键路径的函数，方便学习从协议栈到网卡驱动的实现。</p>
<h3 id="底层网络协议的具体例子"><a href="#底层网络协议的具体例子" class="headerlink" title="底层网络协议的具体例子"></a>底层网络协议的具体例子</h3><p>接下来如果继续介绍 IP 协议和 MAC 协议可能很多读者会晕，所以本节将使用 Wireshark 来通过具体例子讲解，以下是我请求百度首页时抓取到的网络数据：</p>
<p><img src="http://fex.baidu.com/img/what-happen/wireshark-all.png" alt></p>
<p>最底下是实际的二进制数据，中间是解析出来的各个字段值，可以看到其中最底部为 HTTP 协议(Hypertext Transfer Protocol)，在 HTTP 之前有 54 字节(0x36)，这就是底层网络协议所带来的开销，我们接下来对这些协议进行分析。</p>
<p>在 HTTP 之上是 TCP 协议(Transmission Control Protocol)，它的具体内容如下图所示：</p>
<p><img src="http://fex.baidu.com/img/what-happen/wireshark-tcp.png" alt></p>
<h2 id="第三个问题：数据如何从本机网卡发送到服务器？"><a href="#第三个问题：数据如何从本机网卡发送到服务器？" class="headerlink" title="第三个问题：数据如何从本机网卡发送到服务器？"></a>第三个问题：数据如何从本机网卡发送到服务器？</h2><h3 id="从内核到网络适配器-Network-Interface-Card"><a href="#从内核到网络适配器-Network-Interface-Card" class="headerlink" title="从内核到网络适配器(Network Interface Card)"></a>从内核到网络适配器(Network Interface Card)</h3><p>前面说到调用 Socket API 后内核会对数据进行底层协议栈的封装，接下来启动 DMA 控制器，它将从内存中读取数据写入网卡。</p>
<p>以 Nexus 5 为例，它使用的是博通 BCM4339 芯片通信，接口采用了 SD 卡一样的 SDIO，但这个芯片的细节并没有公开资料，所以这里就不讨论了。</p>
<p>连接 Wi-Fi 路由</p>
<p>Wi-Fi 网卡需要通过 Wi-Fi 路由来与外部通信，原理是基于无线电，通过电流变化来产生无线电，这个过程也叫「调制」，而反过来无线电可以引起电磁场变化，从而产生电流变化，利用这个原理就能将无线电中的信息解读出来就叫「解调」，其中单位时间内变化的次数就称为频率，目前在 Wi-Fi 中所采用的频率分为 2.4 GHz 和 5 GHz 两种。</p>
<p>在同一个 Wi-Fi 路由下，因为采用的频率相同，同时使用时会发生冲突，为了解决这个问题，Wi-Fi 采用了被称为 CSMA/CA 的方法，简单来说就是在传输前先确认信道是否已被使用，没有才发送数据。</p>
<blockquote>
<p>而同样基于无线电原理的 2G/3G/LTE 也会遇到类似的问题，但它并没有采用 Wi-Fi 那样的独占方案，而是通过频分(FDMA)、时分(TDMA)和码分(CDMA)来进行复用，具体细节这里就不展开了。以小米路由为例，它使用的芯片是 BCM 4709，这个芯片由 ARM Cortex-A9 处理器及流量(Flow)硬件加速组成，使用硬件芯片可以避免经过操作系统中断、上下文切换等操作，从而提升了性能。</p>
</blockquote>
<p>路由器中的操作系统可以基于 OpenWrt 或 DD-WRT 来开发的，具体细节我不太了解，所以就不展开了。</p>
<p>因为内网设备的 IP 都是类似 192.168.1.x 这样的内网地址，外网无法直接向这个地址发送数据，所以网络数据在经过路由时，路由会修改相关地址和端口，这个操作称为 NAT 映射。</p>
<p>最后家庭路由一般会通过双绞线连接到运营商网络的。</p>
<h3 id="运营商网络内的路由"><a href="#运营商网络内的路由" class="headerlink" title="运营商网络内的路由"></a>运营商网络内的路由</h3><p>数据过双绞线发送到运营商网络后，还会经过很多个中间路由转发，读者可以通过 traceroute 命令或者在线可视化工具来查看这些路由的 ip 和位置。</p>
<p>当数据传递到这些路由器后，路由器会取出包中目的地址的前缀，通过内部的转发表查找对应的输出链路，而这个转发表是如何得到的呢？这就是路由器中最重要的选路算法了，可选的有很多，我对这方面并不太了解，看起来维基百科上的词条列得很全。</p>
<h3 id="主干网间的传输"><a href="#主干网间的传输" class="headerlink" title="主干网间的传输"></a>主干网间的传输</h3><p>对于长线的数据传输，通常使用光纤作为介质，光纤是基于光的全反射来实现的，使用光纤需要专门的发射器通过电致发光（比如 LED）将电信号转成光，比起前面介绍的无线电和双绞线，光纤信号的抗干扰性要强得多，而且能耗也小很多。</p>
<p>既然是基于光来传输数据，数据传输速度也就取决于光的速度，在真空中的光速接近于 30 万千米/秒，由于光纤包层(cladding)中的折射率(refractive index)为 1.52，所以实际光速是 20 万千米/秒左右，从首都机场飞往广州白云机场的距离是 1967 千米，按照这个距离来算需要花费 10 毫秒才能抵达。这意味着如果你在北京，服务器在广州，等你发出数据到服务器返回数据至少得等 20 毫秒，实际情况预计是 2- 3 倍，因为这其中还有各个节点路由处理的耗时，比如我测试了一个广州的 IP 发现平均延迟为 60 毫秒。</p>
<p>这个延迟是现有科技无法解决的（除非找到超过光速的方法），只能通过 CDN 来让传输距离变短，或尽量减少串行的来回请求（比如 TCP 建立连接所需的 3 次握手）。</p>
<h2 id="第四个问题：服务器接收到数据后会进行哪些处理？"><a href="#第四个问题：服务器接收到数据后会进行哪些处理？" class="headerlink" title="第四个问题：服务器接收到数据后会进行哪些处理？"></a>第四个问题：服务器接收到数据后会进行哪些处理？</h2><p>为了避免重复，这里将不再介绍操作系统，而是直接进入后端服务进程，由于这方面有太多技术选型，所以我只挑几个常见的公共部分来介绍。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>请求在进入到真正的应用服务器前，可能还会先经过负责负载均衡的机器，它的作用是将请求合理地分配到多个服务器上，同时具备具备防攻击等功能。</p>
<p>负载均衡具体实现有很多种，有直接基于硬件的 F5，有操作系统传输层(TCP)上的 LVS，也有在应用层(HTTP)实现的反向代理（也叫七层代理），接下来将介绍 LVS 及反向代理。</p>
<p>负载均衡的策略也有很多，如果后面的多个服务器性能均衡，最简单的方法就是挨个循环一遍(Round-Robin)，其它策略就不一一介绍了，可以参考 LVS 中的算法。</p>
<h3 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h3><p>LVS 的作用是从对外看来只有一个 IP，而实际上这个 IP 后面对应是多台机器，因此也被成为 Virtual IP。</p>
<p>前面提到的 NAT 也是一种 LVS 中的工作模式，除此之外还有 DR 和 TUNNEL，具体细节这里就不展开了，它们的缺点是无法跨网段，所以百度自己开发了 BVS 系统。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理是工作在 HTTP 上的，具体实现可以基于 HAProxy 或 Nginx，因为反向代理能理解 HTTP 协议，所以能做非常多的事情，比如：</p>
<p>进行很多统一处理，比如防攻击策略、防抓取、SSL、gzip、自动性能优化等<br>应用层的分流策略都能在这里做，比如对 /xx 路径的请求分到 a 服务器，对 /yy 路径的请求分到 b 服务器，或者按照 cookie 进行小流量测试等<br>缓存，并在后端服务挂掉的时候显示友好的 404 页面<br>监控后端服务是否异常<br>⋯⋯<br>Nginx 的代码写得非常优秀，从中能学到很多，对高性能服务端开发感兴趣的读者一定要看看。</p>
<h3 id="Web-Server-中的处理"><a href="#Web-Server-中的处理" class="headerlink" title="Web Server 中的处理"></a>Web Server 中的处理</h3><p>请求经过前面的负载均衡后，将进入到对应服务器上的 Web Server，比如 Apache、Tomcat、Node.JS 等。</p>
<p>以 Apache 为例，在接收到请求后会交给一个独立的进程来处理，我们可以通过编写 Apache 扩展来处理，但这样开发起来太麻烦了，所以一般会调用 PHP 等脚本语言来进行处理，比如在 CGI 下就是将 HTTP 中的参数放到环境变量中，然后启动 PHP 进程来执行，或者使用 FastCGI 来预先启动进程。</p>
<p>（等后续有空再单独介绍 Node.JS 中的处理）</p>
<h3 id="进入后端语言"><a href="#进入后端语言" class="headerlink" title="进入后端语言"></a>进入后端语言</h3><p>前面说到 Web Server 会调用后端语言进程来处理 HTTP 请求（这个说法不完全正确，有很多其它可能），那么接下来就是后端语言的处理了，目前大部分后端语言都是基于虚拟机的，如 PHP、Java、JavaScript、Python 等，但这个领域的话题非常大，难以讲清楚，对 PHP 感兴趣的读者可以阅读我之前写的 HHVM 介绍文章，其中提到了很多虚拟机的基础知识。</p>
<h3 id="Web-框架-Framework"><a href="#Web-框架-Framework" class="headerlink" title="Web 框架(Framework)"></a>Web 框架(Framework)</h3><p>如果你的 PHP 只是用来做简单的个人主页「Personal Home Page」，倒没必要使用 Web 框架，但如果随着代码的增加会变得越来越难以管理，所以一般网站都会会基于某个 Web 框架来开发，因此在后端语言执行时首先进入 Web 框架的代码，然后由框架再去调用应用的实现代码。</p>
<p>可选的 Web 框架非常多，这里就不一一介绍了。</p>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>这部分不展开了，从简单的读写文件到数据中间层，这里面可选的方案实在太多。</p>
<h2 id="第五个问题：服务器返回数据后浏览器如何处理？"><a href="#第五个问题：服务器返回数据后浏览器如何处理？" class="headerlink" title="第五个问题：服务器返回数据后浏览器如何处理？"></a>第五个问题：服务器返回数据后浏览器如何处理？</h2><p>前面说到服务端处理完请求后，结果将通过网络发回客户端的浏览器，从本节开始将介绍浏览器接收到数据后的处理，值得一提的是这方面之前有一篇不错的文章 How Browsers Work，所以很多内容我不想再重复介绍，因此将重点放在那篇文章所忽略的部分。</p>
<h3 id="从-01-到字符"><a href="#从-01-到字符" class="headerlink" title="从 01 到字符"></a>从 01 到字符</h3><p>HTTP 请求返回的 HTML 传递到浏览器后，如果有 gzip 会先解压，然后接下来最重要的问题是要知道它的编码是什么，比如同样一个「中」字，在 UTF-8 编码下它的内容其实是「11100100 10111000 10101101」也就是「E4 B8 AD」，而在 GBK 下则是「11010110 11010000」，也就是「D6 D0」，如何才能知道文件的编码？可以有很多判断方法：</p>
<p>用户设置，在浏览器中可以指定页面编码<br>HTTP 协议中</p>
<meta> 中的 charset 属性值
对于 JS 和 CSS
对于 iframe
如果在这些地方都没指明，浏览器就很难处理，在它看来就是一堆「0」和「1」，比如「中文」，它在 UTF-8 下有 6 个字节，如果按照 GBK 可以当成「涓枃」这 3 个汉字来解释，浏览器怎么知道到底是「中文」还是「涓枃」呢？

<p>不过正常人一眼就能认出「涓枃」是错的，因为这 3 个字太不常见了，所以有人就想到通过判断常见字的方法来检测编码，典型的比如 Mozilla 的 UniversalCharsetDetection，不过这东东误判率也很高，所以还是指明编码的好。</p>
<p>这样后续对文本的操作就是基于「字符」(Character)的了，一个汉字就是一个字符，不用再关心它究竟是 2 个字节还是 3 个字节。</p>
<h3 id="外链资源的加载"><a href="#外链资源的加载" class="headerlink" title="外链资源的加载"></a>外链资源的加载</h3><p>（待补充，这里有调度策略）</p>
<h3 id="JavaScript-的执行"><a href="#JavaScript-的执行" class="headerlink" title="JavaScript 的执行"></a>JavaScript 的执行</h3><p>（后续再单独介绍，推荐大家看 R 大去年整理的这个帖子，里面有非常多相关资料，另外我两年前曾讲过 JavaScript 引擎中的性能优化，虽然有些内容不太正确了，但也可以看看）</p>
<h3 id="从字符到图片"><a href="#从字符到图片" class="headerlink" title="从字符到图片"></a>从字符到图片</h3><p>二维渲染中最复杂的要数文字显示了，虽然想想似乎很简单，不就是将某个文字对应的字形(glyph)找出来么？在中文和英文中这样做是没问题的，因为一个字符就对应一个字形(glyph)，在字体文件中找到字形，然后画上去就可以了，但在阿拉伯语中是不行的，因为它有有连体形式。</p>
<p>（以后续再单独介绍，这里非常复杂）</p>
<h3 id="跨平台-2D-绘制库"><a href="#跨平台-2D-绘制库" class="headerlink" title="跨平台 2D 绘制库"></a>跨平台 2D 绘制库</h3><p>在不同操作系统中都提供了自己的图形绘制 API，比如 Mac OS X 下的 Quartz，Windows 下的 GDI 以及 Linux 下的 Xlib，但它们相互不兼容，所以为了方便支持跨平台绘图，在 Chrome 中使用了 Skia 库。</p>
<p>（以后再单独介绍，Skia 内部实现调用层级太多，直接讲代码可能不适合初学者）</p>
<h3 id="GPU-合成"><a href="#GPU-合成" class="headerlink" title="GPU 合成"></a>GPU 合成</h3><p>（以后续再单独介绍，虽然简单来说就是靠贴图，但还得介绍 OpenGL 以及 GPU 芯片，内容太长）</p>
<h2 id="第六个问题：浏览器如何将页面展现出来？"><a href="#第六个问题：浏览器如何将页面展现出来？" class="headerlink" title="第六个问题：浏览器如何将页面展现出来？"></a>第六个问题：浏览器如何将页面展现出来？</h2><p>前面提到浏览器已经将页面渲染成一张图片了，接下来的问题就是如何将这张图片展示在屏幕上。</p>
<h3 id="Framebuffer"><a href="#Framebuffer" class="headerlink" title="Framebuffer"></a>Framebuffer</h3><p>以 Linux 为例，在应用中控制屏幕最直接的方法是将图像的 bitmap 写入 /dev/fb0 文件中，这个文件实际上一个内存区域的映射，这段内存区域称为 Framebuffer。</p>
<p>需要注意的是在硬件加速下，如 OpenGL 是不经过 Framebuffer 的。</p>
<h3 id="从内存到-LCD"><a href="#从内存到-LCD" class="headerlink" title="从内存到 LCD"></a>从内存到 LCD</h3><p>在手机的 SoC 中通常都会有一个 LCD 控制器，当 Framebuffer 准备好后，CPU 会通过 AMBA 内部总线通知 LCD 控制器，然后这个控制器读取 Framebuffer 中的数据，进行格式转换、伽马校正等操作，最终通过 DSI、HDMI 等接口发往 LCD 显示器。</p>
<p><a href="https://liyiye012.github.io/2018/08/23/在浏览器地址栏输入URL，按下回车后发生了什么/" target="_blank" rel="noopener">SOURCE2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器向DNS服务器查找输入URL对应的IP地址。</span><br><span class="line">2.DNS服务器返回网站的IP地址。</span><br><span class="line">3.浏览器根据IP地址与目标web服务器在80端口上建立TCP连接</span><br><span class="line">4.浏览器获取请求页面的html代码。</span><br><span class="line">5.浏览器在显示窗口内渲染HTML。</span><br><span class="line">6.窗口关闭时，浏览器终止与服务器的连接。</span><br></pre></td></tr></table></figure>

<p>这其中最有趣的是第1步和第2步(域名解析)。我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。</p>
<h2 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h2><p>①查询ip地址</p>
<p>②建立tcp连接，接入服务器</p>
<p>③浏览器发起http请求</p>
<p>④服务器后台操作并做出http响应</p>
<p>⑤网页的解析与渲染</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><h4 id="查询ip地址"><a href="#查询ip地址" class="headerlink" title="查询ip地址"></a>查询ip地址</h4><p>①浏览器解析出url中的域名。</p>
<p>②查询浏览器的DNS缓存。</p>
<p>③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。</p>
<p>④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。</p>
<p>⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。</p>
<p>⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。</p>
<h4 id="tcp连接与http连接"><a href="#tcp连接与http连接" class="headerlink" title="tcp连接与http连接"></a>tcp连接与http连接</h4><p>①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。</p>
<p>②tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。</p>
<p>③http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</p>
<p>④服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</p>
<p>⑤文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</p>
<p>⑥经过网络传输，文件被下载到本地客户端，客户端开始加载。</p>
<h4 id="html渲染"><a href="#html渲染" class="headerlink" title="html渲染"></a>html渲染</h4><p>①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）<br>。<br>②遇到css文件，css中的url发起http请求。</p>
<p>③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。</p>
<p>④http连接是无状态连接，客户端与服务器端需要重新发起请求–响应。<br>在请求css的过程中，解析器继续解析html，然后到了script标签。</p>
<p>⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。</p>
<p>⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。</p>
<p>⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。</p>
<p>⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</p>
<p>⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</p>
<p>⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</p>
<p>⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</p>
<p>⑫DOM树遇到html结束标签，停止解析，进而渲染结束。</p>
<h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><h4 id="有那些网站优化的方法？"><a href="#有那些网站优化的方法？" class="headerlink" title="有那些网站优化的方法？"></a>有那些网站优化的方法？</h4><p>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p>
<p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p>
<p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p>
<p>④提前渲染开始时间：将css链接放在html头部。</p>
<p>⑤减轻解析器的阻塞：将js链接放在body尾部</p>
<p><a href="https://juejin.im/post/5d5a622ef265da03f47c20e9" target="_blank" rel="noopener">SOURCE3</a><br>作者：曲小强<br>链接：<a href="https://juejin.im/post/5d5a622ef265da03f47c20e9" target="_blank" rel="noopener">https://juejin.im/post/5d5a622ef265da03f47c20e9</a><br>来源：掘金</p>
<h3 id="1、URL解析"><a href="#1、URL解析" class="headerlink" title="1、URL解析"></a>1、URL解析</h3><p>一个URL包括协议，网络地址，资源路径<br>协议：最常用的比如HTTP（超文本传输协议）FTP（文件传输协议）<br>网络地址：可以是域名或者ip地址，包括端口号，如果没有默认为80<br>如果是不合法的地址，会转给默认的搜索引擎,例如如果你正在使用chrome，可以在url输入框输入你想要搜索的内容，然后搜索引擎会根据关键字进行搜索。</p>
<h3 id="2、DNS域名解析"><a href="#2、DNS域名解析" class="headerlink" title="2、DNS域名解析"></a>2、DNS域名解析</h3><p>例如：baidu.com就是域名</p>
<h4 id="1-先到各种缓存信息中查找"><a href="#1-先到各种缓存信息中查找" class="headerlink" title="1.先到各种缓存信息中查找"></a>1.先到各种缓存信息中查找</h4><p>先到浏览器缓存记录中查找——浏览器会缓存DNS一段时间</p>
<p>系统缓存—–如果浏览器中没有找到，浏览器会有一个系统调用，获得系统缓存中的记录</p>
<p>路由器缓存—–接着将请求发给路由器，路由器一般也有自己的DNS缓存</p>
<h4 id="2-DNS服务器查找"><a href="#2-DNS服务器查找" class="headerlink" title="2.DNS服务器查找"></a>2.DNS服务器查找</h4><p>没有则发送请求到本地域名服务器每一个本地域名服务器都维护一个高速缓存，存放最近用过的域名及其IP地址.如果还没有则发出递归查询（本地服务器请求比他高一级的服务器，如此递归直到根域名服务器，肯定能找到这个服务器的IP地址）通过这个IP可以找到客户端到服务器端的唯一路径.</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca91c2e5059c3a?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="3、浏览器主机根据ip地址与服务器建立TCP连接"><a href="#3、浏览器主机根据ip地址与服务器建立TCP连接" class="headerlink" title="3、浏览器主机根据ip地址与服务器建立TCP连接"></a>3、浏览器主机根据ip地址与服务器建立TCP连接</h3><p>浏览器向服务器端发送SYN连接请求，经过服务器与浏览器三次报文的交互连接建立完成，就可以发送数据了。</p>
<p>找到了正确的IP地址以后就要开始建立连接了，建立连接的过程一般会使用TCP协议，通过三次握手建立连接。</p>
<p>TCP 三次握手</p>
<p>客户端发出建立连接的请求。数据包携带有SYN。</p>
<p>如果服务端有开放的端口，可以接受并建立连接，那么服务端会返回SYN + ACK,告诉客户端我可以接受你的请求。</p>
<p>客户端收到服务端的回应，发送ACK给服务端。 连接建立。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca91f52cbaa582?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="4、发送HTTP请求"><a href="#4、发送HTTP请求" class="headerlink" title="4、发送HTTP请求"></a>4、发送HTTP请求</h3><p>与服务器建立了连接后，就可以向服务器发起请求了</p>
<p>根据HTTP协议的要求，组织一个HTTP数据包，向服务器发送HTTP请求，HTTP的请求报头有请求行和请求报头，空行。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca92442fba516e?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述</p>
<h3 id="5、服务器处理请求"><a href="#5、服务器处理请求" class="headerlink" title="5、服务器处理请求"></a>5、服务器处理请求</h3><p>服务器收到请求并响应，生成一个HTTP响应报文，通过TCP协议发送给浏览器主机</p>
<p>通过HTTP请求服务后，服务器会像浏览器返回一个应答信息———-HTTP响应，</p>
<p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca92a5ebf5c329?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。<br>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca92b2e80b9747?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="6、断开TCP连接"><a href="#6、断开TCP连接" class="headerlink" title="6、断开TCP连接"></a>6、断开TCP连接</h3><p>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca92cf4bfb6ca1?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>客户端发起中断请求，发送FIN到服务端</p>
<p>服务端收到请求，可能数据还没有发完。这个时候不会关闭socket，而是回复ACK，告诉客户端知道了</p>
<p>客户端进入Fin_Wait状态，继续等待服务端端的FIN报文。服务端端发送完毕后，会向客户端发送FIN</p>
<p>客户端客服端收到后就回复ACK，并关闭连接</p>
<h3 id="7、浏览器解析文件"><a href="#7、浏览器解析文件" class="headerlink" title="7、浏览器解析文件"></a>7、浏览器解析文件</h3><p>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</p>
<p>要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，（js阻塞问题可以自行百度，或者等我有时间更新一篇文章，单独解释阻塞）</p>
<h3 id="8、浏览器布局渲染"><a href="#8、浏览器布局渲染" class="headerlink" title="8、浏览器布局渲染"></a>8、浏览器布局渲染</h3><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：repaint(重绘)和reflow(回流)。</p>
<blockquote>
<p>repaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p>
</blockquote>
<blockquote>
<p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。</p>
</blockquote>
<p>所以我们应该尽量减少reflow和repaint,良好的css规范会减少这种操作,传送门·CSS书写规范和顺序</p>
<p>最后浏览器绘制各个节点，将页面展示给用户。</p>
<p>致此输入url到展现页面的一个周期就完成了。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Alicia Luo</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://www.alicialuo.com/2020/02/16/输入URL/">https://www.alicialuo.com/2020/02/16/输入URL/</a></span>
                    </p>
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/网络请求/"># 网络请求</a>
                    
                        <a href="/tags/web/"># web</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/02/18/DistributedSystems/">Distributed Systems course material excerpt</a>
            
            
            <a class="next" rel="next" href="/2020/02/16/Leetcode-Graph/">Leetcode Tree & Graph 类问题</a>
            
        </section>


    </article>
</div>

        </div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<footer id="footer" class="footer">
    <div class="copyright">
        <p style="height:20px;margin:0">© Alicia Luo | 👀<span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span></span> </p>
        <p style="height:10px;font-size:80%;margin:0">Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></p>
    </div>
</footer>

    </div>

<script type="text/javascript" color="0,0,0" opacity="0.7" zindex="-2" count="100" src="/js/canvas-nest.js"></script>
<!-- <script type="text/javascript" color="0,0,0" opacity='0.7' zIndex="-2" count="100" src="https://github.com/hustcc/canvas-nest.js/blob/master/dist/canvas-nest.js"></script> -->
</body>
</html>
